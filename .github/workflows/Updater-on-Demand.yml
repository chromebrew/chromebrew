---
name: Generate Updates PRs on Demand
run-name: Generating Updates PRs on Demand using ${{ inputs.version_cmd_input }}
on:
  workflow_dispatch:
    inputs:
      version_cmd_input:
        description: "Input to version.rb command"
        required: true
  workflow_call:
    inputs:
      version_cmd_input:
        type: string
        required: true
env:
  GH_TOKEN: ${{ secrets.CREW_PR_TOKEN }}  # setting GH_TOKEN for the entire workflow
permissions:                    # Global permissions configuration starts here
  actions: write
  contents: write
  packages: write
  pull-requests: write          # 'write' access to pull requests
jobs:
  update-check:
    if: ${{ github.repository_owner == 'chromebrew' }}
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v5
        with:
          persist-credentials: true
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.4.7'
      - name: Install Python pip
        run: sudo apt install -y python3-pip
      - name: Setup Git.
        id: git-setup
        run: |
          git config --global push.autoSetupRemote true
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
      - name: Check for updates.
        id: update-checks
        run: |
          set -x
          export CI=true
          git pull
          git stash drop || true
          echo "pwd is $(pwd)"
          # Make crew do automatic gem installs before looking for deps.
          LD_LIBRARY_PATH=/usr/local/lib ruby bin/crew version
          # Force creation of temporary device.json.
          LD_LIBRARY_PATH=/usr/local/lib ruby bin/crew deps zstd_static
          # Run Update Checks...
          LD_LIBRARY_PATH=/usr/local/lib ruby tools/version.rb -u -v "${{ inputs.version_cmd_input }}"
          for i in $(git status --porcelain | awk '{print $2}' | grep ^packages/)
          do
            git stash pop || true
            pkg=${i%.rb}
            pkg=${pkg#packages/}
            # The updated package version will be the one in the package file.
            pkg_version="$(LD_LIBRARY_PATH=/usr/local/lib ruby bin/crew version ${pkg})"
            if [[ -z "$pkg_version" ]]; then
              branch_tag="$(date -u +%F-%H-%M)"
            else
              branch_tag="${pkg_version}"
            fi
            export updater_branch="updater-${pkg}-${branch_tag}"
            echo "Updater branch: ${updater_branch}"
            if git branch -a | grep -q "${updater_branch}"; then
              echo "Updating & rebasing existing ${updater_branch} branch."
              git stash || true
              git config advice.detachedHead false
              git checkout remotes/origin/"${updater_branch}"
              git pull origin "${updater_branch}"
              # Let build workflow handle rebasing.
              # git pull --rebase origin master; git push origin "HEAD:${updater_branch}" -f ; git pull origin "${updater_branch}"
              git stash pop || true
            else
              git checkout -b "${updater_branch}"
              echo "${updater_branch} branch created."
              git add $i
            fi
            # If there are no changes, the next step will fail, but that
            # is ok.
            git commit -m "Add unbuilt ${pkg} to ${updater_branch}" || true
            git push origin "HEAD:${updater_branch}" -f || true
            gh workflow -R chromebrew/chromebrew run Build.yml -f branch="${updater_branch}" -f pr_label=updater
            git stash || true
            git checkout master
          done

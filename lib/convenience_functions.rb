# lib/convenience_functions.rb
# Extracted bits of crew-specific code that we use frequently enough that it makes sense to split them out to here.
require 'json'
require_relative 'color'
require_relative 'const'
require_relative 'crewlog'
require_relative 'downloader'

class ConvenienceFunctions
  def self.load_symbolized_json
    return JSON.load_file(File.join(CREW_CONFIG_PATH, 'device.json'), symbolize_names: true).transform_values! { |val| val.is_a?(String) ? val.to_sym : val }
  end

  def self.save_json(json_object)
    crewlog 'Saving device.json...'
    begin
      File.write File.join(CREW_CONFIG_PATH, 'device.json.tmp'), JSON.pretty_generate(JSON.parse(json_object.to_json))
    rescue StandardError
      puts 'Error writing updated packages json file!'.lightred
      abort
    end

    # Copy over original if the write to the tmp file succeeds.
    FileUtils.cp("#{CREW_CONFIG_PATH}/device.json.tmp", File.join(CREW_CONFIG_PATH, 'device.json')) && FileUtils.rm("#{CREW_CONFIG_PATH}/device.json.tmp")
  end

  def self.libtoolize(library, lib_pkg_name = nil)
    lib_pkg_name = library if lib_pkg_name.nil?
    libname = library.to_s.start_with?('lib') ? library.downcase : "lib#{library.downcase}"
    puts "Generating libtool file for #{lib_pkg_name}".orange
    puts "grep \"#{CREW_LIB_PREFIX}/#{libname}.so\\\|#{CREW_DEST_LIB_PREFIX}/#{libname}-*.so\" #{CREW_META_PATH}/#{lib_pkg_name}.filelist" if CREW_VERBOSE
    libnames = `grep "#{CREW_LIB_PREFIX}/#{libname}.so\\\|#{CREW_DEST_LIB_PREFIX}/#{libname}-*.so*" #{CREW_META_PATH}/#{lib_pkg_name}.filelist`.chomp.split(/$/).map(&:strip)
    libnames.each do |s|
      s.gsub!("#{CREW_LIB_PREFIX}/", '')
    end
    return if libnames.empty?
    dlname = libnames.grep(/.so./).first
    libname = dlname.gsub(/.so.\d+/, '')
    longest_libname = libnames.max_by(&:length)
    libvars = longest_libname.rpartition('.so.')[2].split('.')

    libtool_file = <<~LIBTOOLEOF
      # #{libname}.la - a libtool library file
      # Generated by libtool (GNU libtool) (Created by Chromebrew)
      #
      # Please DO NOT delete this file!
      # It is necessary for linking the library.

      # The name that we can dlopen(3).
      dlname='#{dlname}'

      # Names of this library.
      library_names='#{libnames.reverse.join(' ')}'

      # The name of the static archive.
      old_library='#{libname}.a'

      # Linker flags that cannot go in dependency_libs.
      inherited_linker_flags=''

      # Libraries that this one depends upon.
      dependency_libs=''

      # Names of additional weak libraries provided by this library
      weak_library_names=''

      # Version information for #{library}.
      current=#{libvars[1]}
      age=#{libvars[1]}
      revision=#{libvars[2]}

      # Is this an already installed library?
      installed=yes

      # Should we warn about portability when linking against -modules?
      shouldnotlink=no

      # Files to dlopen/dlpreopen
      dlopen=''
      dlpreopen=''

      # Directory that this library needs to be installed in:
      libdir='#{CREW_LIB_PREFIX}'
    LIBTOOLEOF
    File.write("#{CREW_LIB_PREFIX}/#{libname}.la", libtool_file)
    puts "Generated #{CREW_LIB_PREFIX}/#{libname}.la..."
  end

  def self.patch(patch_array = [])
    return if patch_array.empty?
    patch_array.each do |patch_item|
      abort 'Patch array is not valid!'.lightred unless patch_item[0]
      abort 'Patch sha256sum does not exist!'.lightred unless patch_item[1]
      patch_file = File.basename(patch_item[0])
      puts "downloader #{patch_item[0]}, #{patch_item[1]}" if CREW_VERBOSE
      downloader patch_item[0], patch_item[1]
      puts "patch -Np1 -i #{patch_file}" if CREW_VERBOSE
      system "patch -Np1 -i #{patch_file}"
    end
  end
end

# lib/convenience_functions.rb
# Extracted bits of crew-specific code that we use frequently enough that it makes sense to split them out to here.
require 'json'
require_relative 'const'
require_relative 'crewlog'

class ConvenienceFunctions
  def self.load_symbolized_json
    return JSON.load_file(File.join(CREW_CONFIG_PATH, 'device.json'), symbolize_names: true).transform_values! { |val| val.is_a?(String) ? val.to_sym : val }
  end

  def self.save_json(json_object)
    crewlog 'Saving device.json...'
    begin
      File.write File.join(CREW_CONFIG_PATH, 'device.json.tmp'), JSON.pretty_generate(JSON.parse(json_object.to_json))
    rescue StandardError
      puts 'Error writing updated packages json file!'.lightred
      abort
    end

    # Copy over original if the write to the tmp file succeeds.
    FileUtils.cp("#{CREW_CONFIG_PATH}/device.json.tmp", File.join(CREW_CONFIG_PATH, 'device.json')) && FileUtils.rm("#{CREW_CONFIG_PATH}/device.json.tmp")
  end

  def self.libtoolize(library, lib_pkg_name = nil)
    lib_pkg_name = library if lib_pkg_name.nil?
    libname = library.to_s.start_with?('lib') ? library.downcase : "lib#{library.downcase}"
    file_array = []
    lib_array = []
    # nmresults = `nm  -A *.so* 2>/dev/null | grep ucol_open_#{oldver}`.chop.split(/$/).map(&:strip)
    # nmresults.each { |file_line| lib_array.push(file_line.partition(':').first) }
    # lib_array.each do |f|
    # grepresults = `grep "#{f}" #{CREW_META_PATH}/*.filelist`.chomp.gsub('.filelist', '').partition(':').first.gsub(
    # CREW_META_PATH, ''
    # ).split(/$/).map(&:strip)
    # grepresults.each { |file_line| file_array.push(file_line) }
    # end

    # libnames = Dir["#{CREW_LIB_PREFIX}/#{libname}.so*"]
    puts "grep \"#{CREW_LIB_PREFIX}/#{libname}.so\\\|#{CREW_DEST_LIB_PREFIX}/#{libname}-*.so\" #{CREW_META_PATH}/#{lib_pkg_name}.filelist" if CREW_VERBOSE
    libnames = `grep "#{CREW_LIB_PREFIX}/#{libname}.so\\\|#{CREW_DEST_LIB_PREFIX}/#{libname}-*.so*" #{CREW_META_PATH}/#{lib_pkg_name}.filelist`.chomp.split(/$/).map(&:strip)
    # libnames = Dir["#{CREW_DEST_LIB_PREFIX}/#{libname}-*.so*"] if libnames.empty?
    libnames.each do |s|
      s.gsub!("#{CREW_LIB_PREFIX}/", '')
    end
    return if libnames.empty?
    dlname = libnames.grep(/.so./).first
    libname = dlname.gsub(/.so.\d+/, '')
    longest_libname = libnames.max_by(&:length)
    libvars = longest_libname.rpartition('.so.')[2].split('.')

    libtool_file = <<~LIBTOOLEOF
      # #{libname}.la - a libtool library file
      # Generated by libtool (GNU libtool) (Created by Chromebrew)
      #
      # Please DO NOT delete this file!
      # It is necessary for linking the library.

      # The name that we can dlopen(3).
      dlname='#{dlname}'

      # Names of this library.
      library_names='#{libnames.reverse.join(' ')}'

      # The name of the static archive.
      old_library='#{libname}.a'

      # Linker flags that cannot go in dependency_libs.
      inherited_linker_flags=''

      # Libraries that this one depends upon.
      dependency_libs=''

      # Names of additional weak libraries provided by this library
      weak_library_names=''

      # Version information for #{library}.
      current=#{libvars[1]}
      age=#{libvars[1]}
      revision=#{libvars[2]}

      # Is this an already installed library?
      installed=yes

      # Should we warn about portability when linking against -modules?
      shouldnotlink=no

      # Files to dlopen/dlpreopen
      dlopen=''
      dlpreopen=''

      # Directory that this library needs to be installed in:
      libdir='#{CREW_LIB_PREFIX}'
    LIBTOOLEOF
    File.write("#{CREW_LIB_PREFIX}/#{libname}.la", libtool_file)
    puts "Generated #{CREW_LIB_PREFIX}/#{libname}.la..."
  end
end
